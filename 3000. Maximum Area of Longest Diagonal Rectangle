

## ðŸ”¹ Intuition

We are given multiple rectangles, each with dimensions `[a, b]`.

* The **diagonal length** of a rectangle is `âˆš(aÂ² + bÂ²)`.
* To find the rectangle with the **maximum diagonal**, we donâ€™t actually need the square root. Since `âˆš` is a monotonically increasing function, comparing `aÂ² + bÂ²` directly is enough.
* If two rectangles have the same diagonal, we should choose the one with the **larger area** (`a Ã— b`).

So, the idea is:

* For each rectangle, compute `diagSq = aÂ² + bÂ²` and `area = a Ã— b`.
* Keep track of the rectangle with the **largest diagonal**; in case of ties, pick the **largest area**.

---

## ðŸ”¹ Approach

1. Initialize variables:

   * `maxDiagSq` = -1 (store the best diagonal squared found so far).
   * `maxArea` = -1 (store the area corresponding to the best rectangle).

2. Loop over each rectangle:

   * Extract sides `a` and `b`.
   * Compute `diagSq = aÂ² + bÂ²`.
   * Compute `area = a Ã— b`.
   * If `diagSq > maxDiagSq`, update both `maxDiagSq` and `maxArea`.
   * If `diagSq == maxDiagSq`, then check if `area > maxArea` and update if true.

3. After processing all rectangles, return `maxArea`.

---

## ðŸ”¹ Complexity

* **Time Complexity:**

  * We iterate through all `n` rectangles once.
  * Each iteration does O(1) work (just arithmetic operations).
  * **Total:** `O(n)`.

* **Space Complexity:**

  * We only store a few integers (`maxDiagSq`, `maxArea`).
  * **Total:** `O(1)` (constant extra space).

---

## ðŸ”¹ Code



class Solution {
public:
    int areaOfMaxDiagonal(vector<vector<int>>& dimensions) {
        int n = dimensions.size();
        int maxDiagSq = -1;   
        int maxArea = -1;     

        for (int i = 0; i < n; i++) {
            int a = dimensions[i][0];
            int b = dimensions[i][1];
            int diagSq = a * a + b * b;  
            int area = a * b;

            
            if (diagSq > maxDiagSq || (diagSq == maxDiagSq && area > maxArea)) {
                maxDiagSq = diagSq;
                maxArea = area;
            }
        }

        return maxArea;
    }
};
